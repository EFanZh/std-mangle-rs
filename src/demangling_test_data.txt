# Test cases for symbol demangling
#
# File format: Every pair of lines where the first one starts with '#' and the
# second one starts with "_R" is a test case. The first line gives the title of
# the test, the second gives the mangled and (after the first whitespace)
# demangled versions of a symbol.
# Anything that doesn't conform to the syntax above is supposed to be ignored.



## Basic Types

# Demangle i8
_RN7std_xxx3FooIaEE std[xxx]::Foo<i8>
# Demangle i16
_RN7std_xxx3FooIsEE std[xxx]::Foo<i16>
# Demangle i32
_RN7std_xxx3FooIlEE std[xxx]::Foo<i32>
# Demangle i64
_RN7std_xxx3FooIxEE std[xxx]::Foo<i64>
# Demangle i128
_RN7std_xxx3FooInEE std[xxx]::Foo<i128>
# Demangle isize
_RN7std_xxx3FooIiEE std[xxx]::Foo<isize>

# Demangle u8
_RN7std_xxx3FooIhEE std[xxx]::Foo<u8>
# Demangle u16
_RN7std_xxx3FooItEE std[xxx]::Foo<u16>
# Demangle u32
_RN7std_xxx3FooImEE std[xxx]::Foo<u32>
# Demangle u64
_RN7std_xxx3FooIyEE std[xxx]::Foo<u64>
# Demangle u128
_RN7std_xxx3FooIoEE std[xxx]::Foo<u128>
# Demangle usize
_RN7std_xxx3FooIjEE std[xxx]::Foo<usize>

# Demangle f32
_RN7std_xxx3FooIfEE std[xxx]::Foo<f32>
# Demangle f64
_RN7std_xxx3FooIdEE std[xxx]::Foo<f64>
# Demangle bool
_RN7std_xxx3FooIbEE std[xxx]::Foo<bool>
# Demangle char
_RN7std_xxx3FooIcEE std[xxx]::Foo<char>
# Demangle unit
_RN7std_xxx3FooIuEE std[xxx]::Foo<()>
# Demangle never
_RN7std_xxx3FooIzEE std[xxx]::Foo<!>
# Demangle str
_RN7std_xxx3FooIeEE std[xxx]::Foo<str>
# Demangle ellipsis
_RN7std_xxx3FooIvEE std[xxx]::Foo<...>



## Statics

# Static at crate level
_RN16mycrate_abcd123f3FOOSE mycrate[abcd123f]::FOO

# Static in module
_RN16mycrate_abcd123f3bar3FOOSE mycrate[abcd123f]::bar::FOO

# Static in function
_RN16mycrate_abcd123f3fooF4QUUXSE mycrate[abcd123f]::foo::QUUX

# Static with mixed module/function/static path
_RN16mycrate_abcd123f3bar3fooF3bazS4quuxFE mycrate[abcd123f]::bar::foo::baz::quux

# Static with unicode name
...

# Static with unicode module in path
...

# Static with disambiguated name
_RN16mycrate_abcd123f3foo3BARSs_E mycrate[abcd123f]::foo::BAR'2

# Static with disambiguated module in path
_RN16mycrate_abcd123f3foos0_3BARSE mycrate[abcd123f]::foo'3::BAR

# Static with closure in path
_RN16mycrate_abcd123f3fooF1_C4QUUXSE mycrate[abcd123f]::foo::{closure}'1::QUUX

# Static with generic inherent impl in path
_RNMN7std_xxx3FooIG1TEEE4quuxF3BARSE std[xxx]::Foo<T>::quux::BAR

# Static with trait impl in path
_RNXiN16mycrate_abcd123f9SomeTraitE4quuxF3FOOSE <isize as mycrate[abcd123f]::SomeTrait>::quux::FOO

# Static with specialized trait impl in path
_RNXiN16mycrate_abcd123f9SomeTraitEs_4quuxF3FOOSE <isize as mycrate[abcd123f]::SomeTrait>'2::quux::FOO



## Non-generic functions

# Free-standing function at crate level
_RN16mycrate_abcd123f4quuxFE mycrate[abcd123f]::quux

# Free-standing function in module
_RN16mycrate_abcd123f3foo4quuxFE mycrate[abcd123f]::foo::quux

# Free-standing function in function
_RN16mycrate_abcd123f3fooF3barFE mycrate[abcd123f]::foo::bar

# Free-standing function with mixed module/function/Static path
_RN16mycrate_abcd123f3bar3fooF3BARS4quuxFE mycrate[abcd123f]::bar::foo::BAR::quux

# Free-standing function with unicode name
...

# Free-standing function with unicode module in path
...

# Free-standing function with disambiguated name
_RN16mycrate_abcd123f3foo4quuxFs_E mycrate[abcd123f]::foo::quux'2

# Free-standing function with disambiguated module in path
_RN16mycrate_abcd123f3foos0_4quuxFE mycrate[abcd123f]::foo'3::quux

# Free-standing function with closure in path
_RN16mycrate_abcd123f3foo1_C3barFE mycrate[abcd123f]::foo::{closure}'1::bar

# Free-standing function with trait impl in path
_RNXReN11mycrate_xyz3FooE3foo6helperE <&str as mycrate[xyz]::Foo>::foo::helper

# Free-standing function with specialized trait impl in path
_RNXmN8std_12345DebugE4quuxFE <u32 as std[1234]::Debug>::quux



## Generic functions

# Generic function with basic type argument
_RN16mycrate_abcd123f3barFImEE mycrate[abcd123f]::bar<u32>

# Generic function with named type argument
_RN16mycrate_abcd123f5closeFIN8std_12342fs4FileEEE mycrate[abcd123f]::close<std[1234]::fs::File>

# Generic function with tuple type argument
_RN16mycrate_abcd123f3bazFITccEEE mycrate[abcd123f]::baz<(char,char)>

# Generic function with shared reference type argument
_RN16mycrate_abcd123f3bazFIReEE mycrate[abcd123f]::baz<&str>

# Generic function with mutable reference type argument
_RN16mycrate_abcd123f3bazFIQeEE mycrate[abcd123f]::baz<&mut str>

# Generic function with const pointer type argument
_RN16mycrate_abcd123f3bazFIPaEE mycrate[abcd123f]::baz<*const i8>

# Generic function with mut pointer type argument
_RN16mycrate_abcd123f3bazFIOhEE mycrate[abcd123f]::baz<*mut u8>

# Generic function with function type argument
_RN16mycrate_abcd123f3bazFIFmJcEEE mycrate[abcd123f]::baz<fn(u32) -> char>

# Generic function with unsized array type argument
_RN16mycrate_abcd123f3bazFIAtEE mycrate[abcd123f]::baz<[u16]>

# Generic function with sized array type argument
_RN16mycrate_abcd123f3bazFIA777sEE mycrate[abcd123f]::baz<[i16; 777]>

# Generic function with named type parameter
_RN16mycrate_abcd123f3bazFIG1TEEE mycrate[abcd123f]::baz<T>

# Generic function with disambiguated, named type parameter
_RN16mycrate_abcd123f3bazFIG1Ts9_EEE mycrate[abcd123f]::baz<T'12>

# Generic function with unicode named type argument
...

# Generic function with closure type argument
_RN16mycrate_abcd123f3bazFIN16mycrate_abcd123f3foo1_Cs0_EEE mycrate[abcd123f]::baz<mycrate[abcd123f]::foo::{closure}'3>

# Generic function with disambiguated named type arguments
_RN16mycrate_abcd123f3bazFIN16mycrate_abcd123f3Foos_EEE mycrate[abcd123f]::baz<mycrate[abcd123f]::Foo'2>

# Generic function with named type argument defined in simple trait impl
_RN8std_23453mem8align_ofFINXjN16mycrate_abcd123f9SomeTraitE3fooF3BarEEE std[2345]::mem::align_of<<usize as mycrate[abcd123f]::SomeTrait>::foo::Bar>

# Generic function with named type argument defined in specialized trait impl
_RN8std_23453mem8align_ofFINXjN16mycrate_abcd123f9SomeTraitEs_3fooF3BarEEE std[2345]::mem::align_of<<usize as mycrate[abcd123f]::SomeTrait>'2::foo::Bar>

# Generic function with instantiating crate suffix
_RN16mycrate_abcd123f3barFImEE20some_other_crate_xxx mycrate[abcd123f]::bar<u32> @ some_other_crate[xxx]



## Inherent methods

# Inherent non-generic method
_RNMN8std_12342fs4FileE5closeFE std[1234]::fs::File::close

# Inherent method with generic impl
_RNMN8std_12343vec3VecIcEE4pushFE std[1234]::vec::Vec<char>::push

# Generic inherent method
_RNMN8std_12346string6StringE6retainFIN7xxx_yyy9predicateFEEE std[1234]::string::String::retain<xxx[yyy]::predicate>

# Generic inherent method with generic impl
_RNMN8std_12343vec3VecIsEE6retainFIN7xxx_yyy9predicateFEEE std[1234]::vec::Vec<i16>::retain<xxx[yyy]::predicate>

# Inherent method with basic self type
_RNMi5to_leFE isize::to_le

# Inherent method with tuple self type
_RNMTcccE3fooFE (char,char,char)::foo

# Inherent method with array self type
_RNMAs4quuxFE [i16]::quux

# Inherent method with function self type
_RNMFUKcE4quuxFE unsafe extern "C" fn()::quux

# Inherent method with reference self type
_RNMRa4quuxFE &i8::quux

# Inherent method with pointer self type
_RNMPu4quuxFE *const ()::quux

# Inherent method with disambiguated named self type
_RNMN7std_xxx3Foos_E4quuxFE std[xxx]::Foo'2::quux



## Trait methods

# Non-generic trait method
_RNXcN7std_xxx5CloneE5cloneFE <char as std[xxx]::Clone>::clone

# Trait method with generic self-type
_RNXN7std_xxx3BarImEEN7std_xxx5CloneE5cloneFE <std[xxx]::Bar<u32> as std[xxx]::Clone>::clone

# Trait method with generic trait
_RNXN7std_xxx3BarEN7std_xxx3FooIaEE5cloneFE <std[xxx]::Bar as std[xxx]::Foo<i8>>::clone

# Generic trait method with generic trait and generic self-type
_RNXN7std_xxx3BarEN7std_xxx3FooIaEE4quuxFIReEE <std[xxx]::Bar as std[xxx]::Foo<i8>>::quux<&str>

# Trait method with basic self-type
_RNXuN7std_xxx3FooE4quuxFE <() as std[xxx]::Foo>::quux

# Trait method with tuple self-type
_RNXTmyEN7std_xxx3FooE4quuxFE <(u32,u64) as std[xxx]::Foo>::quux

# Trait method with reference self-type
_RNXQTmyEN7std_xxx3FooE4quuxFE <&mut (u32,u64) as std[xxx]::Foo>::quux

# Trait method with disambiguated named self type
_RNXN14some_crate_yyy3Bars_EN7std_xxx3FooE4quuxFE <some_crate[yyy]::Bar'2 as std[xxx]::Foo>::quux



## Closures

# Closure in free-standing function
_RN7std_xxx3fooF1_Cs0_E std[xxx]::foo::{closure}'3

# Closure in closure
_RN7std_xxx3fooF1_Cs0_1_CE std[xxx]::foo::{closure}'3::{closure}'1

# Closure in inherent method
_RNMm3fooF1_Cs_E u32::foo::{closure}'2

# Closure in trait method
_RNXlN7foo_xxx3BarIxEE4quuxF1_Cs_IcEE <i32 as foo[xxx]::Bar<i64>>::quux::{closure}'2<char>



## Compression

# Compressed name prefix as qname
_RNXN7std_xxx3foo3FooES0_3barFE <std[xxx]::foo::Foo as std[xxx]::foo>::bar

# Compressed name prefix as type
_RN7std_xxx3fooFIS0_EE std[xxx]::foo<std[xxx]::foo>

# Compressed name prefix as type name prefix
_RN7std_xxx3fooFINS0_3BarEEE std[xxx]::foo<std[xxx]::foo::Bar>

# Compressed basic type crate root
_RN7std_xxx3fooFINMa3barINS0_3BARSEEEEE std[xxx]::foo<i8::bar<std[xxx]::foo::BAR>>

# Compressed named type crate root
_RN7std_xxx3fooFINMNS_4QUUXE3barINS0_3BARSEEEEE std[xxx]::foo<std[xxx]::QUUX::bar<std[xxx]::foo::BAR>>

# Compressed prefix constructed from prefix that contains substitution itself
_RN7std_xxx3fooFINS_3barFENS1_3bazFEEE std[xxx]::foo<std[xxx]::bar,std[xxx]::bar::baz>

# Progressive type compression
_RN7std_xxx3fooITNS_3BarES1_ES2_EE std[xxx]::foo<(std[xxx]::Bar,std[xxx]::Bar),(std[xxx]::Bar,std[xxx]::Bar)>

# Substituted instantiating crate suffix
_RN16mycrate_abcd123f3barFImEES_ mycrate[abcd123f]::bar<u32> @ mycrate[abcd123f]

# Compressed generic parameter
_RN16mycrate_abcd123f3barFIG1TES1_EE mycrate[abcd123f]::bar<T,T>
